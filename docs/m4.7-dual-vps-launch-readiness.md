# M4.7 Dual VPS Launch Readiness (V1 + V2)

## Objective
Run V1 and V2 on one VPS (or one cluster) with strict separation:

- separate app stacks
- separate Postgres databases/volumes
- API-level handshake only (no cross-DB writes)

## Hostnames

Recommended:

- `api-zenops.notalonestudios.com` -> V2 API
- `studio-zenops.notalonestudios.com` -> V2 Studio
- `portal-zenops.notalonestudios.com` -> V2 Portal
- `api-v1-zenops.notalonestudios.com` -> V1 API
- `v1-zenops.notalonestudios.com` -> V1 frontend

## Compose Project Separation

Use distinct compose project names:

- V2: `COMPOSE_PROJECT_NAME=zenops-v2`
- V1: `COMPOSE_PROJECT_NAME=zenops-v1`

Avoid shared service/container names.

## Database Separation (Non-Negotiable)

- V2 DB volume: e.g. `zenops_v2_pgdata`
- V1 DB volume: e.g. `zenops_v1_pgdata`
- Separate DB credentials and `DATABASE_URL` values
- No direct SQL reads/writes from one app into the other app DB

## V1 -> V2 Handshake Configuration

Set in V1 backend environment:

- `STUDIO_BASE_URL=https://api-zenops.notalonestudios.com`
- `STUDIO_SERVICE_TOKEN=<shared-service-token>`
- `DEFAULT_BILLING_MODE=POSTPAID`

Use the same token in V2 API env as `STUDIO_SERVICE_TOKEN`.

## Runtime Identity Validation

Always validate target app identity before automation/scripts:

```bash
curl -sS https://api-zenops.notalonestudios.com/v1/meta
curl -sS https://api-v1-zenops.notalonestudios.com/v1/meta
```

Expected:

- V2: `"app":"zenops-v2"`
- V1: `"app":"zenops-v1"`

## Billing Topology at Launch

- V2 Studio owns billing control plane:
  - account policies
  - credit ledger/reservations
  - billing event intake
- V1 remains operational for postpaid invoicing initially
- V1 emits billing events to V2 through service token auth

## Cutover Safety

1. Keep postpaid as default for early customers.
2. Enable credit mode per-account in V2 Studio when ready.
3. Monitor event flow and reconciliation before larger migrations.
