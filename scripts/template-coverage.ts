import { readFileSync, writeFileSync, readdirSync, statSync } from 'node:fs';
import { join, relative } from 'node:path';

/**
 * Template Coverage Script
 *
 * Scans all .docx files in docs/templates/samples/ using PizZip to extract
 * XML body text and detect any {{placeholder}} tags. Diffs against the
 * RenderContext canonical keys and outputs TEMPLATE_COVERAGE_REPORT.md.
 *
 * Usage: npx tsx scripts/template-coverage.ts
 *
 * NOTE: The real samples contain actual data, not {{tags}} yet.
 * This script honestly reports "0 placeholders found" for unannotated files.
 */

// We use PizZip directly to avoid import issues with docxtemplater's inspect module
// eslint-disable-next-line @typescript-eslint/no-var-requires
const PizZip = require('pizzip');

const SAMPLES_DIR = join(__dirname, '..', 'docs', 'templates', 'samples');
const OUTPUT_REPORT = join(__dirname, '..', 'docs', 'templates', 'TEMPLATE_COVERAGE_REPORT.md');

const CANONICAL_KEYS = [
    'meta.bankName', 'meta.branchName', 'meta.reportFamily', 'meta.slabRule',
    'meta.loanProduct', 'meta.inspectionDate', 'meta.assignmentDate', 'meta.reportDate',
    'meta.valuerSignatory', 'meta.exportHash', 'meta.templateHash', 'meta.generatedAt',
    'parties.borrowerName', 'parties.ownerName', 'parties.contactDetails',
    'property.propertyType', 'property.addressFull', 'property.villageTown',
    'property.surveyNumber', 'property.khataNumber', 'property.builtUpAreaSqm', 'property.landAreaSqm',
    'rates.guidelineRateSqm', 'rates.guidelineValueTotal', 'rates.marketRateInput',
    'rates.adoptedRateInput', 'rates.marketRateSqm', 'rates.adoptedRateSqm',
    'valuation.landValue', 'valuation.buildingValue', 'valuation.fmv',
    'valuation.realizableValue', 'valuation.distressValue', 'valuation.guidanceValue',
    'valuation.bookValue', 'valuation.coopAdoptedValue', 'valuation.coopRoundedTotal', 'valuation.valueInWords',
    'depreciation.ageYears', 'depreciation.totalLifeYears', 'depreciation.depreciationPct',
    'geo.latitude', 'geo.longitude',
    'manual.justificationMissingApprovedPlan', 'manual.justificationValuationVariance', 'manual.operatorNotes',
    'evidence.photos', 'evidence.annexures',
    'isCoop', 'isSbi', 'isBoi'
];

function collectDocxFiles(dir: string): string[] {
    const results: string[] = [];
    for (const entry of readdirSync(dir)) {
        const full = join(dir, entry);
        if (statSync(full).isDirectory()) {
            results.push(...collectDocxFiles(full));
        } else if (entry.endsWith('.docx') && !entry.startsWith('~')) {
            results.push(full);
        }
    }
    return results;
}

function extractPlaceholders(filePath: string): string[] {
    const raw = readFileSync(filePath, 'binary');
    let zip: any;
    try {
        zip = new PizZip(raw);
    } catch {
        return [];
    }

    // Extract text content from all XML parts
    const placeholders = new Set<string>();
    const tagRegex = /\{\{([^}]+)\}\}/g;

    for (const [name, entry] of Object.entries(zip.files) as [string, any][]) {
        if (!name.endsWith('.xml') && !name.endsWith('.xml.rels')) continue;
        try {
            const text: string = entry.asText();
            let match;
            while ((match = tagRegex.exec(text)) !== null) {
                placeholders.add(match[1].trim());
            }
        } catch {
            // skip binary entries
        }
    }
    return Array.from(placeholders).sort();
}

function run() {
    const files = collectDocxFiles(SAMPLES_DIR);
    const allFound = new Set<string>();

    let md = '# M5.7 Template Coverage Report\n\n';
    md += `> Auto-generated by \`scripts/template-coverage.ts\` on ${new Date().toISOString()}\n`;
    md += '> Scans all .docx files in `docs/templates/samples/` for `{{placeholder}}` tags.\n\n';
    md += `**Canonical RenderContext keys:** ${CANONICAL_KEYS.length}\n\n`;

    for (const file of files) {
        const rel = relative(SAMPLES_DIR, file);
        const tags = extractPlaceholders(file);
        tags.forEach(t => allFound.add(t));

        md += `## \`${rel}\`\n`;
        if (tags.length === 0) {
            md += '**Placeholders found:** 0 — this file contains real data, not template tags yet.\n';
        } else {
            md += `**Placeholders found:** ${tags.length}\n`;
            md += '```\n' + tags.join('\n') + '\n```\n';
            const missing = tags.filter(t => !CANONICAL_KEYS.includes(t));
            if (missing.length > 0) {
                md += `\n**⚠️ Not in RenderContext (${missing.length}):**\n`;
                missing.forEach(m => { md += `- \`${m}\`\n`; });
            } else {
                md += '\n**✅ All placeholders covered by RenderContext.**\n';
            }
        }
        md += '\n---\n\n';
    }

    const unusedKeys = CANONICAL_KEYS.filter(k => !allFound.has(k));
    md += `## Context Keys Unused by Templates (${unusedKeys.length})\n\n`;
    if (allFound.size === 0) {
        md += '> All keys are unused because the samples contain real data, not `{{tags}}`.\n';
        md += '> This is the expected baseline. Template annotation is a future manual step.\n';
    } else {
        unusedKeys.forEach(k => { md += `- \`${k}\`\n`; });
    }

    writeFileSync(OUTPUT_REPORT, md, 'utf8');
    console.log(`✅ Coverage report written to ${relative(process.cwd(), OUTPUT_REPORT)}`);
    console.log(`   Templates scanned: ${files.length}`);
    console.log(`   Placeholders found: ${allFound.size}`);
}

run();
